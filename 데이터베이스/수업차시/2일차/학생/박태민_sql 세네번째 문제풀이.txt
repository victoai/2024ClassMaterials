-- sql 세번째
-- select 절
-- 1. 고객등급 조회
select * from member_tbl_11;
select m_grade from member_tbl_11;

-- 2. 중복값 제외후 조회
select * from member_tbl_11;
select distinct m_grade from member_tbl_11;

-- 3. 고객테이블로부터 아이디 USERID라는 이름으로 조회하기 (AS 는 생략가능)
select * from member_tbl_11;
select m_id USERID from member_tbl_11;

-- 4. 고객테이블로부터 이름에 ‘님’자를 붙여 NAME이라는 컬럼으로 조회
select * from member_tbl_11;
select m_name||' 님' from member_tbl_11;


-- 문자함수
CREATE TABLE CUST_INFO(
 ID VARCHAR2(13) NOT NULL PRIMARY KEY , FIRST_NM VARCHAR2(10) , LAST_NM VARCHAR2(10) , ANNL_PERF NUMBER(10,2) 
);

INSERT INTO CUST_INFO VALUES ('8301111567897' , 'JHUN' , 'KIM', 330.08);
INSERT INTO CUST_INFO VALUES ('9302112567897' , 'JINYOUNG' , 'LEE', 857.61);
INSERT INTO CUST_INFO VALUES ('8801111567897' , 'MIJA' , 'HAN', -76.77);
INSERT INTO CUST_INFO VALUES ('9901111567897' , 'YOUNGJUN' , 'HA', 468.54);
INSERT INTO CUST_INFO VALUES ('9801112567897' , 'DAYOUNG' , 'SUNG', -890);
INSERT INTO CUST_INFO VALUES ('9701111567897' , 'HYEJIN' , 'SEO', 47.44);
COMMIT;

select * from cust_info;

-- 1. 고객정보 테이블로부터 주민번호 7번째 숫자 (성별을 나타내는)를 추출하여 GENDER 라는 이름으로 주민번호와 함께 조회
select * from cust_info;
select id, substr(id, 7, 1) from cust_info;

-- 2. 고객정보 테이블로부터 주민번호, LAST_NM을 모두 소문자로 조회
select * from cust_info;
select id, lower(last_nm) from cust_info;

-- 3. 고객정보 테이블로부터 DM발송을 위해서 NAME이라는 이름으로  KIM, JIHOON 과 같은형식으로 조회
select * from cust_info;
select last_nm || ', ' || first_nm as name from cust_info;

-- 숫자함수
-- 1.  고객정보 테이블로부터 고객 주민번호, 수익을 소수 둘째에서 반올림하여 소수 첫째자리까지 표시될 수 있도록 조회 
select * from cust_info;
select id, round(annl_perf, 1) from cust_info;

-- 2. 고객정보 테이블로부터 고객 주민번호, 수익을 소수 첫째에서 버림하여 정수로 나타낼수 있도록 조회
select * from cust_info;
select id, trunc(annl_perf, 0) from cust_info;

-- 날짜함수
-- 1. 현재날짜를 조회
select sysdate from dual;

-- 조건식
-- 1. 고객테이블로부터 주민번호 , 수익이 300이상이면 고수익 100이상은 일반수익 0이하이면 손해 , 나머지는 변동없음 내용이 RESULT컬럼명으로 조회
select * from cust_info;
select id, case when annl_perf >= 300 then '고수익'  when annl_perf >= 100 then '일반수익' when annl_perf<=0 then '손해'  else '변동없음'
                        end as "result"  from cust_info;
                        
-- 기타함수
-- 1. 고객테이블로부터 이름과 포인트를 조회하시오(단 포인트가 적립되지 않은 고객은 0으로 표시)
select * from member_tbl_11;
select m_name, m_point, nvl(m_point, 0) from member_tbl_11;

-- 2. 고객테이블로부터 기존포인트 점수에서 100포인트씩 인상하려고 합니다. NEXT_POINT라는 컬럼으로 조회되도록 하시오, 고객이름, 포인트와 함께 조회하시오 ( 기존포인트가 없는 사람은 0으로 간주)
select * from member_tbl_11;
select m_name, nvl2(m_point, m_point+100, 0) next_point from member_tbl_11;



-- sql 네번째
CREATE TABLE STUD_SCORE(
  STUDENT_ID        VARCHAR2(13) NOT NULL PRIMARY KEY ,
  MATH_SCORE      NUMBER(5) ,
  ENG_SCORE        NUMBER(5)   ,
  PHIL_SCORE       NUMBER(5)   ,
  MUSIC_SCORE    NUMBER(5) 
);

INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE,   ENG_SCORE, PHIL_SCORE , MUSIC_SCORE)   VALUES ('0123511' , 89,78,78,90);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE,   ENG_SCORE,  MUSIC_SCORE)   VALUES ('0255475' , 88,90,90);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE  , MUSIC_SCORE)   VALUES ('9921100' , 87,98);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE, ENG_SCORE, PHIL_SCORE , MUSIC_SCORE)   VALUES ('9732453' , 69,98,78,78);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE, ENG_SCORE, PHIL_SCORE )   VALUES ('0578981' , 59,90,89);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE, ENG_SCORE, PHIL_SCORE , MUSIC_SCORE)   VALUES ('0768789' , 94,80,87,99);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE, ENG_SCORE, PHIL_SCORE , MUSIC_SCORE)   VALUES ('9824579' , 90,90,78,87);
INSERT INTO  STUD_SCORE ( STUDENT_ID , MATH_SCORE, ENG_SCORE, PHIL_SCORE )   VALUES ('0565789' , 58,64,72);

commit;

-- 1. STUD_SCORE 테이블을 사용하여 NULL값을 포함한 행의 개수
select * from stud_score;
select count(*) from stud_score;

--2. STUD_SCORE 테이블을 사용하여 NULL값을 제외한 제외한 음악 점수 보유자
select * from stud_score;
select count(music_score) from stud_score;

--3. STUD_SCORE 테이블을 사용하여 수학 점수의 총 합계
select * from stud_score;
select sum(math_score) from stud_score;

-- 4. STUD_SCORE 테이블을사용하여 음악 점수의 평균
select * from stud_score;
select avg(music_score) from stud_score;

-- 5. STUD_SCORE 테이블을 사용하여 수학점수 최댓값 및 최솟값
select * from stud_score;
select max(math_score) from stud_score;
select min(math_score) from stud_score;

-- 조건문 이해하기
CREATE TABLE STAFF_SAL(
  ID         VARCHAR2(13) NOT NULL PRIMARY KEY ,
  JOB       VARCHAR2(13) ,
  CURRENT_SAL      NUMBER(10)   ,
  ENG_SCORE        NUMBER(5)    
);

INSERT INTO  STAFF_SAL    VALUES ('2148', 'OFFICER' , 40000, 90);
INSERT INTO  STAFF_SAL    VALUES ('5780', 'CLERK' , 32000, 98);
INSERT INTO  STAFF_SAL    VALUES ('6870', 'MANAGER' , 100000, 81);
INSERT INTO  STAFF_SAL    VALUES ('4565', 'CLERK' , 30000, 79);
INSERT INTO  STAFF_SAL    VALUES ('9687', 'CLERK' , 33000, 66);
INSERT INTO  STAFF_SAL    VALUES ('7337', 'MANAGER' , 100000, 95);
INSERT INTO  STAFF_SAL    VALUES ('1321', 'OFFICER' , 43000, 80);
INSERT INTO  STAFF_SAL    VALUES ('9896', 'CLERK' , 30000, 50);

commit;

-- 6.  CLERK는 7% , OFFICER는 5% , MANAGER는 3%로 연봉을 인상하기로 했다.
-- STAFF_SAL테이블을 사용하여 각 직원별 인상 연봉을 예상해보자 ( CASE WEHN 사용해보기 )
-- (현재연봉을 기준으로 직위별 예상연봉
select * from staff_sal;
select job, current_sal, case 
  when job='CLERK' then current_sal*1.07
  when job='OFFICER' then current_sal*1.05
  when job='MANAGER' then current_sal*1.03
  end as "예상연봉" from staff_sal;
  

-- 데이터의 그룹화
CREATE TABLE PRC(
CUST_ID      VARCHAR2(13) NOT NULL PRIMARY KEY ,
SET2            VARCHAR2(13) ,
CARD_FLAG     NUMBER(1)   ,
LOAN_FLAG     NUMBER(1)   ,
INSURANCE_FLAG     NUMBER(1)   ,
CTB_FLAG     NUMBER(1)   ,
FUND_FLAG    NUMBER(1)   ,
ANNL_REV   NUMBER(10)      
);

INSERT INTO  PRC    VALUES ('546515' , 'SILVER' , 1,1,1,1,1,1000);
INSERT INTO  PRC    VALUES ('46780' , 'GOLD' , 0,0,1,1,0,20000);
INSERT INTO  PRC    VALUES ('237848' , 'GOLD' , 1,1,0,1,1,30000);
INSERT INTO  PRC    VALUES ('56432' , 'DIAMOND' , 1,0,1,1,1,10000);
INSERT INTO  PRC    VALUES ('89647' , 'SILVER' , 0,0,1,1,0,3000);
INSERT INTO  PRC    VALUES ('52333' , 'SILVER' , 1,1,0,1,0,2500 );
INSERT INTO  PRC    VALUES ('89669' , 'GOLD' , 1,0,1,1,0,60000);
INSERT INTO  PRC    VALUES ('21004' , 'SILVER' , 0,0,1,1,0,1000);
INSERT INTO  PRC    VALUES ('17890' , 'DIAMOND' , 1,1,0,1,0,300000);
 
COMMIT;

select * from prc;
-- 1. PRC 테이블을 사용하여 고객등급별 인당 평균 연 수익을 계산
select * from prc;
select set2, avg(annl_rev)
from prc
group by set2;

-- 2.  PRC 테이블을 사용하여 고객등급별 고객 수를 확인
select * from prc;
select set2, count(cust_id)
from prc
group by set2;

-- having 절
CREATE TABLE   PROD_SALES(
CUST_NM         VARCHAR2(13)  ,
PRD_ID             VARCHAR2(5) ,
SALES_AMT       NUMBER(10)      
);

INSERT INTO   PROD_SALES   VALUES ('LEE', 546 , 3000);
INSERT INTO   PROD_SALES   VALUES ('KIM', 326 , 4780);
INSERT INTO   PROD_SALES   VALUES ('KANG', 564 , 87900);
INSERT INTO   PROD_SALES   VALUES ('KWON', 556 , 45478);
INSERT INTO   PROD_SALES   VALUES ('KIM', 254 , 3000);
INSERT INTO   PROD_SALES   VALUES ('YOO', 567 , 78900);
INSERT INTO   PROD_SALES   VALUES ('PARK', 877 , 89787);
INSERT INTO   PROD_SALES   VALUES ('LEE', 890 , 10000);
INSERT INTO   PROD_SALES   VALUES ('KIM', 787 , 2341);
INSERT INTO   PROD_SALES   VALUES ('PARK', 566 , 50000);

commit;

select * from PROD_SALES;

-- 3. 구매횟수가 두 번 이상인 고객에게 마케팅을 하려고 한다. 마케팅 대상자의 고객이름을 조회
select * from PROD_SALES;
select cust_nm, count(cust_nm) from PROD_SALES
group by cust_nm
having count(cust_nm)>=2;









 
 
